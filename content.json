{"meta":{"title":"Filaret's Blooooooooooog","subtitle":"精通写炸送分题","description":"初二弱鸡C++ OIER","author":"FilaretKun / deadpool123 / FILARET","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"最短路算法及优化一览","date":"2019-08-21T07:30:24.798Z","updated":"2019-08-21T07:32:16.579Z","comments":true,"path":"2019/08/21/最短路算法及优化一览/","link":"","permalink":"http://yoursite.com/2019/08/21/最短路算法及优化一览/","excerpt":"","text":"最短路算法及优化一览概述本文章为本蒟蒻对最短路问题的各种算法做的整合。 目录 Floyd 算法 Edsger Wybe Dijkstra 算法 Edsger Wybe Dijkstra 算法 堆优化 SPFA 算法 SPFA 算法 SLF优化 Floyd 算法 Floyd算法本质上就是将任意两个点进行插点，从而求出多源最短路 复杂度：$Θ(n ^ 3)$ 12345678int g[MAXN][MAXN];for(int k = 1 ; k &lt;= N ; k ++) &#123; // 选取进行插点操作的中间点 for(int i = 1 ; i &lt;= N ; i ++) &#123; // 选取起始点 for(int j = 1 ; j &lt;= N ; j ++) &#123; // 选取中止点 g[i][j] = min(g[i][j], g[i][k] + g[k][j]); // 进行插点操作 &#125; &#125;&#125; Edsger Wybe Dijkstra 算法 E.W.Dijkstra算法是一种计算单源最短路的算法 其方法为循环找到某个点的最近的未被操作过的点，将某个点的最短路径进行更新 若其最短路径变量未被更新过，即此点不与任何顶点相连，弹出循环 继续操作，将其标记为已被操作，并对其进行最短路径的取min值计算 复杂度：$Θ(V ^ 2)$ 1234567891011121314151617for(int i = 1 ; i &lt;= N ; i ++) &#123; int minDistance = INF; int nearVertex = 0; for(int j = 1 ; j &lt;= N ; j ++) &#123; if(!vis[j] &amp;&amp; dis[j] &lt; minDistance) &#123; // 找到离此点最近的未被操作过的点 minDistance = dis[j]; nearVertex = j; &#125; &#125; if(minDistance == INF) &#123; // 此点没有和其余任何点相邻 break; &#125; vis[nearVertex] = true; // 将此点标为操作过的点 for(int j = 0 ; j &lt; g[nearVertex].size() ; j ++) &#123; // 更新最短路径 dis[g[nearVertex][j].v] = min(dis[g[nearVertex][j].v] + d[nearVertex] + g[nearVertex][j].w); // 取min操作 &#125;&#125; Edsger Wybe Dijkstra 算法 [优化:堆] 讽刺的是，堆优化的E.W.Dijkstra算法优化的是找到最近的未被操作过的点的过程 但是，这种方法还需要不停的维护基于priority_queue基础上的堆 复杂度：$Θ(E × log(E))$ 1234567891011121314151617181920212223242526priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; minHeap;// 使用pair进行存储，用vector进行底层的存储，优先次序设为从小到大的greater// pair的first = 从起始点到当前点的距离// pair的second = 当前点的编号minHeap.push(makepair(0, S));// 将起始点push进minHeapwhile(minHeap.size()) &#123; // minHeap为空之前一直进行算法运算 int minDistance = minHeap.top().first; // 找到与另外点的最短路径 int nearVertex = minHeap.top().second; // 找到和此点有最短路径的点的编号 min_heap.pop(); // 将其pop出minHeap并继续运算 if(minDistance != dis[nearVertex]) &#123; continue; // 若找到新的最短路径 // continue到下一个点 &#125; for(int i = 0 ; i &lt; g[v].size() ; i ++) &#123; if(dis[g[nearVertex][i].v] &gt; dis[nearVertex] + g[nearVertex][i].w) &#123; dis[g[nearVertex][i].v] = dis[nearVertex] + g[nearVertex][i].w // 更新最短路径 minHeap.push(makepair(dis[g[nearVertex][i].v], g[nearVertex][i].v)); &#125; &#125;&#125; SPFA 算法 Shorter Path Faster Algorithm 的缩写，但由于它无论如何进行优化都会被毒瘤的出题人卡的体无完肤，我个人喜欢管其称之为 Shorter Path Fxxking Algorithm (笑) 思路较为简单，详情见代码注释 复杂度：$Θ(V × E)$ 123456789101112131415161718192021222324252627282930313233bool inQueue[MAXN];// 标记此节点是否在队列中int dis[MAXN];// 记录最短距离queue&lt;int&gt; q;// 嗯……就是你3秒之前刚见到的那个队列void spfa(int s) &#123; memset(in_queue, 0, sizeof(in_queue)); memset(d, 0x3f, sizeof(d)); dis[s] = 0; // 将其自己的最短路径标为0 q.push(s); inQueue[s] = 1; // 以上为初始化部分 while(!q.empty()) &#123; // 说实话呢，SPFA算法比较像BFS // 但是众所周知BFS求最短路是错的…… int V = q.front(); q.pop(); inQueue[s] = 0; //记录后弹出队列+标记 for(int i = 0 ; i &lt; g[V].size() ; i ++) &#123; int X = g[V][i].v; if(dis[X] &gt; dis[V] + g[V][i].w) &#123; // 更新 dis[X] = dis[V] + g[V][i].w; if(!in_queue[X]) &#123; // 如果之前没有进行过入队操作 q.push(X); in_queue[X] = true; // 入队 &#125; &#125; &#125; &#125; in_queue[s] = true; // 进行标记&#125; SPFA 算法 [优化：SLF] SLF，Short Label First的缩写。思路非常简单，即将队列q进行些许的改进。将使用双端队列Deque进行优化。 优化方式：将一个要压入队列的点x的dis值和队首元素y的dis值进行判断，如果dis[x] &lt; dis[y]，则将x压入q的front，不然就压入q的back。 代码正如其他优化代码，可在SPFA本体上直接进行修改。 12345678910111213141516171819202122232425262728293031323334bool inQueue[MAXN];int dis[MAXN];deque&lt;int&gt; q;// void spfa(int s) &#123; memset(in_queue, 0, sizeof(in_queue)); memset(d, 0x3f, sizeof(d)); dis[s] = 0; // 将其自己的最短路径标为0 q.push_front(s); inQueue[s] = 1; // 以上为初始化部分 while(!q.empty()) &#123; int V = q.front(); q.pop_front(); // 弹出双端队列 inQueue[s] = 0; for(int i = 0 ; i &lt; g[V].size() ; i ++) &#123; int X = g[V][i].v; if(dis[X] &gt; dis[V] + g[V][i].w) &#123; // 更新 dis[X] = dis[V] + g[V][i].w; if(!in_queue[X]) &#123; // 如果之前没有进行过入队操作 if(dis[X] &lt;= dis[V]) &#123; q.push_front(X); &#125; else &#123; q.push_back(V); &#125; // 进行判断并通过判断结果决定要将X压入到front还是back &#125; &#125; &#125; &#125; in_queue[s] = true; // 进行标记&#125; 本蒟蒻正在努力学习SPFA的各种屡次被出题人卡掉的玄学优化……请各位巨神将可供本蒟蒻学习的算法或建议洛谷私信发送给我（deadpool123，过段时间后可能会更名为Filaret） 我会感激不尽的呢","categories":[],"tags":[]},{"title":"","slug":"对普及组模拟赛的反思","date":"2019-08-21T04:30:19.372Z","updated":"2019-08-21T04:40:31.260Z","comments":true,"path":"2019/08/21/对普及组模拟赛的反思/","link":"","permalink":"http://yoursite.com/2019/08/21/对普及组模拟赛的反思/","excerpt":"","text":"对普及组模拟赛的反思反思这次比赛很水但导致我没有AK的原因归根结底来说还是因为我的马虎（要是在NOIP赛场上这样搞我就完了）…… 意料之外的事情T4本以为时间复杂度炸了但还是能A我觉得非常神奇…… 居然两次用到了前缀和而且还有不常见的多位前缀和 实属意外 T1错因没有去考虑如果两数之差大于M的情况。 T2错因将==写成了=…… 这种低级错误我不知道是第几次犯了…… 如何避免出现此等错误避免是肯定没法避免的。要增加查出错误的几率需要着重检查=和==有没有写对。分析题目的时候一定要仔细万分：不能因为某题是个T1就懈怠。","categories":[],"tags":[]}]}